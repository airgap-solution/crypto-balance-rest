/*
Crypto Balance API

Derives addresses from an extended public key (XPUB) or equivalent, retrieves balances for a given cryptocurrency, and converts them to the requested fiat currency using an external rate service. 

API version: 1.0.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cryptobalancerest

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiBalanceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	xpub *string
	currency *string
	fiat *string
}

// Extended public key to derive addresses from.
func (r ApiBalanceGetRequest) Xpub(xpub string) ApiBalanceGetRequest {
	r.xpub = &xpub
	return r
}

// Cryptocurrency symbol.
func (r ApiBalanceGetRequest) Currency(currency string) ApiBalanceGetRequest {
	r.currency = &currency
	return r
}

// Fiat currency symbol.
func (r ApiBalanceGetRequest) Fiat(fiat string) ApiBalanceGetRequest {
	r.fiat = &fiat
	return r
}

func (r ApiBalanceGetRequest) Execute() (*BalanceGet200Response, *http.Response, error) {
	return r.ApiService.BalanceGetExecute(r)
}

/*
BalanceGet Get account balance in crypto and fiat

Retrieves the balance for an extended public key (XPUB or equivalent),
calculates its value in the requested fiat currency, and returns
the current balance along with the 24-hour change in fiat value.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBalanceGetRequest
*/
func (a *DefaultAPIService) BalanceGet(ctx context.Context) ApiBalanceGetRequest {
	return ApiBalanceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BalanceGet200Response
func (a *DefaultAPIService) BalanceGetExecute(r ApiBalanceGetRequest) (*BalanceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BalanceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.BalanceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xpub == nil {
		return localVarReturnValue, nil, reportError("xpub is required and must be specified")
	}
	if r.currency == nil {
		return localVarReturnValue, nil, reportError("currency is required and must be specified")
	}
	if r.fiat == nil {
		return localVarReturnValue, nil, reportError("fiat is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "xpub", r.xpub, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "fiat", r.fiat, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
